<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>TAF DOG Museum</title>
  
  <!-- OGP Settings -->
  <meta property="og:title" content="TAF DOG Museum">
  <meta property="og:description" content="TAF DOGコレクションの3Dバーチャル美術館。ローポリゴンの犬たちに会いに来てね。">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tafdog-museum.pages.dev/">
  <meta property="og:image" content="https://kimura-jane.github.io/tafdog_museum/taf_dog_01.png">
  
  <!-- Twitter Card Settings -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="TAF DOG Museum">
  <meta name="twitter:description" content="TAF DOGコレクションの3Dバーチャル美術館。ローポリゴンの犬たちに会いに来てね。">
  <meta name="twitter:image" content="https://kimura-jane.github.io/tafdog_museum/taf_dog_01.png">

  <script src="https://cdn.tailwindcss.com"></script>
  
  <script>
    window.process = { env: { NODE_ENV: 'production' } };
  </script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; user-select: none; -webkit-user-select: none; }
    #root { width: 100%; height: 100%; }
    ::-webkit-scrollbar { display: none; }
    .loading-screen { position: fixed; inset: 0; background: #000; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 1rem; z-index: 9999; }
    .loading-spinner { width: 48px; height: 48px; border: 3px solid #333; border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>

  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "three": "https://esm.sh/three@0.160.0",
      "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
      "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber"
    }
  }
  </script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root">
    <div class="loading-screen" id="loading">
      <div class="loading-spinner"></div>
      <div style="font-size:14px;letter-spacing:0.2em;color:#888;">LOADING MUSEUM...</div>
    </div>
  </div>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useEffect, useMemo, Suspense, useCallback } from "react";
    import { createRoot } from "react-dom/client";
    import { Canvas, useFrame, useThree } from "@react-three/fiber";
    import { OrbitControls, Text } from "@react-three/drei";
    import * as THREE from "three";

    // ==========================================
    // 定数・設定
    // ==========================================
    const ROOM_SIZE = 40;
    const WALL_HEIGHT = 12;
    const NFT_CONFIG = {
      contractAddress: "0xDD8aEA78eebc6b444d960A18D282F453195d55A9",
      ownerWallet: "0x8242dae5c6ff90b03d15c54cad95c3ed97ac0571",
      totalSupply: 100,
      imageBaseUrl: "https://raw.githubusercontent.com/kimura-jane/gazo/main/"
    };

    // 変化条件
    const CHANGE_RULES = {
      "1": "埼玉の気温25℃以上で変化",
      "4": "30日ごとに切り替わる",
      "7": "昼(6-18時)と夜で変化",
      "10": "土日だけ変化",
      "13": "土日だけ変化（別デザイン）",
      "16": "金曜17-24時だけ変化",
      "19": "毎日21-23時だけ変化",
      "22": "毎日20-21時だけ変化",
      "25": "毎日12-13時だけ変化",
      "28": "毎日0-2時だけ変化",
      "35": "水曜日だけ変化",
      "38": "金・土・日だけ変化",
      "53": "平日9-17時だけ変化",
      "58": "火曜19-21時だけ変化",
      "65": "埼玉で雨の時だけ変化",
      "70": "毎日15-16時だけ変化",
      "75": "毎日5-7時だけ変化",
      "80": "月末だけ変化",
      "90": "第2土曜日だけ変化",
      "100": "毎日2-5時だけ変化"
    };

    // NFTデータ生成
    const generateNFTData = () => {
      const nfts = [];
      for (let i = 1; i <= NFT_CONFIG.totalSupply; i++) {
        const paddedId = String(i).padStart(3, "0");
        nfts.push({
          tokenId: String(i),
          imageUrl: `${NFT_CONFIG.imageBaseUrl}tafdog_${paddedId}.png`,
          stateImageUrl: CHANGE_RULES[String(i)] ? `${NFT_CONFIG.imageBaseUrl}tafdog_${paddedId}_state.png` : null,
          changeRule: CHANGE_RULES[String(i)] || null,
          owner: null,
          ownerShort: "Loading..."
        });
      }
      return nfts;
    };

    const ALL_NFTS = generateNFTData();

    // 照明設定（時間帯別）
    const getLighting = () => {
      const hour = new Date().getHours();
      if (hour >= 6 && hour < 10) return { ambient: 0xfff5e6, intensity: 0.6, name: "morning" };
      if (hour >= 10 && hour < 17) return { ambient: 0xffffff, intensity: 0.7, name: "day" };
      if (hour >= 17 && hour < 20) return { ambient: 0xffddbb, intensity: 0.5, name: "evening" };
      return { ambient: 0x334455, intensity: 0.3, name: "night" };
    };

    // アバターカラー
    const HUMAN_COLORS = [
      { skin: "#ffdbac", shirt: "#4a90d9", pants: "#2d3436", hair: "#3d2314" },
      { skin: "#f1c27d", shirt: "#e74c3c", pants: "#1a1a2e", hair: "#1a1a1a" },
      { skin: "#ffdbac", shirt: "#2ecc71", pants: "#2c3e50", hair: "#5d4e37" },
      { skin: "#d4a574", shirt: "#9b59b6", pants: "#2d3436", hair: "#1a1a1a" }
    ];

    const DOG_COLORS = [
      { body: "#d4a574", ear: "#c49464" },
      { body: "#f5f5dc", ear: "#e8e8d0" },
      { body: "#1a1a1a", ear: "#0d0d0d" },
      { body: "#ffffff", ear: "#eeeeee" }
    ];

    // ==========================================
    // ローポリ人間アバター
    // ==========================================
    const HumanAvatar = ({ colorIndex = 0, isMoving = false }) => {
      const group = useRef();
      const colors = HUMAN_COLORS[colorIndex % HUMAN_COLORS.length];
      
      useFrame((state) => {
        if (!group.current) return;
        const t = state.clock.elapsedTime;
        const swing = isMoving ? Math.sin(t * 10) * 0.4 : 0;
        
        // 腕と足のアニメーション
        const leftArm = group.current.children.find(c => c.name === "leftArm");
        const rightArm = group.current.children.find(c => c.name === "rightArm");
        const leftLeg = group.current.children.find(c => c.name === "leftLeg");
        const rightLeg = group.current.children.find(c => c.name === "rightLeg");
        
        if (leftArm) leftArm.rotation.x = swing;
        if (rightArm) rightArm.rotation.x = -swing;
        if (leftLeg) leftLeg.rotation.x = -swing * 0.7;
        if (rightLeg) rightLeg.rotation.x = swing * 0.7;
      });

      return (
        <group ref={group}>
          {/* 頭 */}
          <mesh position={[0, 1.55, 0]}>
            <sphereGeometry args={[0.22, 12, 10]} />
            <meshStandardMaterial color={colors.skin} flatShading />
          </mesh>
          {/* 髪 */}
          <mesh position={[0, 1.65, 0]}>
            <sphereGeometry args={[0.23, 12, 8, 0, Math.PI * 2, 0, Math.PI * 0.5]} />
            <meshStandardMaterial color={colors.hair} flatShading />
          </mesh>
          {/* 首 */}
          <mesh position={[0, 1.28, 0]}>
            <cylinderGeometry args={[0.08, 0.1, 0.12, 8]} />
            <meshStandardMaterial color={colors.skin} flatShading />
          </mesh>
          {/* 胴体 */}
          <mesh position={[0, 0.97, 0]}>
            <cylinderGeometry args={[0.18, 0.22, 0.5, 8]} />
            <meshStandardMaterial color={colors.shirt} flatShading />
          </mesh>
          {/* 腰 */}
          <mesh position={[0, 0.65, 0]}>
            <cylinderGeometry args={[0.2, 0.18, 0.15, 8]} />
            <meshStandardMaterial color={colors.pants} flatShading />
          </mesh>
          {/* 左腕 */}
          <group name="leftArm" position={[-0.28, 1.1, 0]}>
            <mesh position={[0, -0.15, 0]}>
              <cylinderGeometry args={[0.05, 0.06, 0.3, 8]} />
              <meshStandardMaterial color={colors.shirt} flatShading />
            </mesh>
            <mesh position={[0, -0.35, 0]}>
              <sphereGeometry args={[0.05, 8, 6]} />
              <meshStandardMaterial color={colors.skin} flatShading />
            </mesh>
          </group>
          {/* 右腕 */}
          <group name="rightArm" position={[0.28, 1.1, 0]}>
            <mesh position={[0, -0.15, 0]}>
              <cylinderGeometry args={[0.05, 0.06, 0.3, 8]} />
              <meshStandardMaterial color={colors.shirt} flatShading />
            </mesh>
            <mesh position={[0, -0.35, 0]}>
              <sphereGeometry args={[0.05, 8, 6]} />
              <meshStandardMaterial color={colors.skin} flatShading />
            </mesh>
          </group>
          {/* 左足 */}
          <group name="leftLeg" position={[-0.1, 0.5, 0]}>
            <mesh position={[0, -0.25, 0]}>
              <cylinderGeometry args={[0.06, 0.07, 0.5, 8]} />
              <meshStandardMaterial color={colors.pants} flatShading />
            </mesh>
            <mesh position={[0, -0.52, 0.03]}>
              <boxGeometry args={[0.08, 0.05, 0.14]} />
              <meshStandardMaterial color="#222" flatShading />
            </mesh>
          </group>
          {/* 右足 */}
          <group name="rightLeg" position={[0.1, 0.5, 0]}>
            <mesh position={[0, -0.25, 0]}>
              <cylinderGeometry args={[0.06, 0.07, 0.5, 8]} />
              <meshStandardMaterial color={colors.pants} flatShading />
            </mesh>
            <mesh position={[0, -0.52, 0.03]}>
              <boxGeometry args={[0.08, 0.05, 0.14]} />
              <meshStandardMaterial color="#222" flatShading />
            </mesh>
          </group>
          {/* 影 */}
          <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.01, 0]}>
            <circleGeometry args={[0.3, 16]} />
            <meshBasicMaterial color="#000" transparent opacity={0.3} depthWrite={false} />
          </mesh>
        </group>
      );
    };

    // ==========================================
    // ローポリ犬アバター
    // ==========================================
    const DogAvatar = ({ colorIndex = 0, isMoving = false }) => {
      const group = useRef();
      const colors = DOG_COLORS[colorIndex % DOG_COLORS.length];

      useFrame((state) => {
        if (!group.current) return;
        const t = state.clock.elapsedTime;
        
        // しっぽ振り
        const tail = group.current.children.find(c => c.name === "tail");
        if (tail) tail.rotation.z = Math.sin(t * 8) * 0.4;
        
        // 歩行時のバウンス
        if (isMoving) {
          group.current.position.y = Math.abs(Math.sin(t * 12)) * 0.05;
        } else {
          group.current.position.y = 0;
        }
      });

      return (
        <group ref={group}>
          {/* 胴体 */}
          <mesh position={[0, 0.35, 0]}>
            <boxGeometry args={[0.35, 0.3, 0.6]} />
            <meshStandardMaterial color={colors.body} flatShading />
          </mesh>
          {/* 頭 */}
          <mesh position={[0, 0.5, 0.35]}>
            <boxGeometry args={[0.3, 0.28, 0.28]} />
            <meshStandardMaterial color={colors.body} flatShading />
          </mesh>
          {/* マズル */}
          <mesh position={[0, 0.42, 0.52]}>
            <boxGeometry args={[0.15, 0.12, 0.15]} />
            <meshStandardMaterial color={colors.body} flatShading />
          </mesh>
          {/* 鼻 */}
          <mesh position={[0, 0.44, 0.6]}>
            <boxGeometry args={[0.06, 0.05, 0.03]} />
            <meshStandardMaterial color="#333" />
          </mesh>
          {/* 目 */}
          <mesh position={[-0.08, 0.55, 0.47]}>
            <sphereGeometry args={[0.035, 8, 6]} />
            <meshStandardMaterial color="#222" />
          </mesh>
          <mesh position={[0.08, 0.55, 0.47]}>
            <sphereGeometry args={[0.035, 8, 6]} />
            <meshStandardMaterial color="#222" />
          </mesh>
          {/* 耳 */}
          <mesh position={[-0.12, 0.7, 0.3]} rotation={[0.2, 0, 0.3]}>
            <coneGeometry args={[0.08, 0.18, 4]} />
            <meshStandardMaterial color={colors.ear} flatShading />
          </mesh>
          <mesh position={[0.12, 0.7, 0.3]} rotation={[0.2, 0, -0.3]}>
            <coneGeometry args={[0.08, 0.18, 4]} />
            <meshStandardMaterial color={colors.ear} flatShading />
          </mesh>
          {/* 足 */}
          {[[-0.12, 0.12, 0.2], [0.12, 0.12, 0.2], [-0.12, 0.12, -0.2], [0.12, 0.12, -0.2]].map((pos, i) => (
            <mesh key={i} position={pos}>
              <cylinderGeometry args={[0.04, 0.05, 0.25, 8]} />
              <meshStandardMaterial color={colors.ear} flatShading />
            </mesh>
          ))}
          {/* しっぽ */}
          <mesh name="tail" position={[0, 0.5, -0.35]} rotation={[-0.8, 0, 0]}>
            <cylinderGeometry args={[0.02, 0.04, 0.25, 6]} />
            <meshStandardMaterial color={colors.body} flatShading />
          </mesh>
          {/* 影 */}
          <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0.01, 0]}>
            <circleGeometry args={[0.25, 16]} />
            <meshBasicMaterial color="#000" transparent opacity={0.3} depthWrite={false} />
          </mesh>
        </group>
      );
    };

    // ==========================================
    // 投げるターゲットキャラ
    // ==========================================
    const TargetCharacter = ({ position, onHit }) => {
      const [hitCount, setHitCount] = useState(0);
      const [isHurt, setIsHurt] = useState(false);
      const [isFlyingAway, setIsFlyingAway] = useState(false);
      const [flyY, setFlyY] = useState(0);
      const group = useRef();

      useFrame((state, delta) => {
        if (!group.current) return;
        
        if (isFlyingAway) {
          setFlyY(prev => prev + delta * 5);
          group.current.rotation.z += delta * 3;
          group.current.scale.multiplyScalar(0.98);
          if (flyY > 15) {
            group.current.visible = false;
          }
        } else {
          group.current.rotation.y += delta * 0.5;
        }
      });

      const handleHit = () => {
        if (isFlyingAway) return;
        setHitCount(prev => {
          const newCount = prev + 1;
          if (newCount >= 10) {
            setIsFlyingAway(true);
          }
          return newCount;
        });
        setIsHurt(true);
        setTimeout(() => setIsHurt(false), 200);
      };

      // 親コンポーネントにヒット関数を公開
      useEffect(() => {
        if (onHit) onHit.current = handleHit;
      }, []);

      const texture = useMemo(() => {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 384;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          ctx.fillStyle = "#ff6b6b";
          ctx.beginPath();
          ctx.ellipse(128, 250, 60, 80, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#ffd93d";
          ctx.beginPath();
          ctx.arc(128, 120, 70, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#333";
          ctx.beginPath();
          ctx.arc(100, 110, 12, 0, Math.PI * 2);
          ctx.arc(156, 110, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(128, 145, 25, 0.1 * Math.PI, 0.9 * Math.PI);
          ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }, []);

      return (
        <group ref={group} position={[position[0], position[1] + flyY, position[2]]}>
          <mesh>
            <planeGeometry args={[2, 3]} />
            <meshBasicMaterial 
              map={texture} 
              transparent 
              side={THREE.DoubleSide}
              color={isHurt ? "#ff0000" : "#ffffff"}
            />
          </mesh>
          {hitCount > 0 && !isFlyingAway && (
            <Text position={[0, 2, 0]} fontSize={0.3} color="white">
              {hitCount}/10
            </Text>
          )}
        </group>
      );
    };

    // ==========================================
    // 豆
    // ==========================================
    const Bean = ({ startPos, targetPos, onComplete }) => {
      const ref = useRef();
      const [progress, setProgress] = useState(0);

      useFrame((state, delta) => {
        if (!ref.current) return;
        const newProgress = Math.min(progress + delta * 2, 1);
        setProgress(newProgress);

        const t = newProgress;
        ref.current.position.x = startPos[0] + (targetPos[0] - startPos[0]) * t;
        ref.current.position.z = startPos[2] + (targetPos[2] - startPos[2]) * t;
        ref.current.position.y = startPos[1] + (targetPos[1] - startPos[1]) * t + Math.sin(t * Math.PI) * 2;
        ref.current.rotation.x += 0.3;
        ref.current.rotation.y += 0.2;

        if (newProgress >= 1) {
          onComplete();
        }
      });

      return (
        <mesh ref={ref} position={startPos}>
          <sphereGeometry args={[0.08, 8, 6]} />
          <meshStandardMaterial color="#d4a574" flatShading />
        </mesh>
      );
    };

    // ==========================================
    // NFTフレーム
    // ==========================================
    const ArtFrame = ({ nft, position, rotation, onClick }) => {
      const [texture, setTexture] = useState(null);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        const loader = new THREE.TextureLoader();
        loader.setCrossOrigin("anonymous");
        const proxyUrl = `https://wsrv.nl/?url=${encodeURIComponent(nft.imageUrl)}&w=512`;
        
        loader.load(
          proxyUrl,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            setTexture(tex);
            setLoading(false);
          },
          undefined,
          () => setLoading(false)
        );
      }, [nft.imageUrl]);

      return (
        <group position={position} rotation={rotation} onClick={onClick}>
          {/* フレーム */}
          <mesh position={[0, 0, 0.1]} castShadow>
            <boxGeometry args={[4.4, 4.4, 0.2]} />
            <meshStandardMaterial color="#1a1a1a" roughness={0.3} />
          </mesh>
          {/* マット */}
          <mesh position={[0, 0, 0.2]}>
            <boxGeometry args={[4, 4, 0.05]} />
            <meshStandardMaterial color="#ffffff" />
          </mesh>
          {/* 画像 */}
          <mesh position={[0, 0, 0.25]}>
            <planeGeometry args={[3.5, 3.5]} />
            {texture ? (
              <meshBasicMaterial map={texture} />
            ) : (
              <meshStandardMaterial color={loading ? "#333" : "#222"} />
            )}
          </mesh>
          {/* スポットライト */}
          <pointLight position={[0, 2, 1]} intensity={1} distance={8} decay={2} />
        </group>
      );
    };

    // ==========================================
    // 部屋（1階: 美術館 / 2階: オフィス）
    // ==========================================
    const Room = ({ floor, nfts, onSelectNFT }) => {
      const isMuseum = floor === 1;
      const floorColor = isMuseum ? "#f5f5f5" : "#deb887";
      const wallColor = isMuseum ? "#fafafa" : "#e0e0e0";

      // NFTを壁に配置
      const positions = useMemo(() => {
        const result = [];
        const perWall = Math.ceil(nfts.length / 4);
        const spacing = (ROOM_SIZE - 8) / Math.max(perWall, 1);

        nfts.forEach((nft, index) => {
          const wallIndex = Math.floor(index / perWall);
          const posIndex = index % perWall;
          const offset = (posIndex - (perWall - 1) / 2) * spacing;

          let pos, rot;
          switch (wallIndex) {
            case 0:
              pos = [offset, 5, -ROOM_SIZE / 2 + 1];
              rot = [0, 0, 0];
              break;
            case 1:
              pos = [ROOM_SIZE / 2 - 1, 5, offset];
              rot = [0, -Math.PI / 2, 0];
              break;
            case 2:
              pos = [-offset, 5, ROOM_SIZE / 2 - 1];
              rot = [0, Math.PI, 0];
              break;
            default:
              pos = [-ROOM_SIZE / 2 + 1, 5, -offset];
              rot = [0, Math.PI / 2, 0];
          }
          result.push({ nft, pos, rot });
        });
        return result;
      }, [nfts]);

      return (
        <group>
          {/* 床 */}
          <mesh rotation={[-Math.PI / 2, 0, 0]} receiveShadow>
            <planeGeometry args={[ROOM_SIZE, ROOM_SIZE]} />
            <meshStandardMaterial color={floorColor} roughness={isMuseum ? 0.2 : 0.8} />
          </mesh>

          {/* 壁 */}
          {[
            { pos: [0, WALL_HEIGHT / 2, -ROOM_SIZE / 2], rot: [0, 0, 0] },
            { pos: [0, WALL_HEIGHT / 2, ROOM_SIZE / 2], rot: [0, 0, 0] },
            { pos: [ROOM_SIZE / 2, WALL_HEIGHT / 2, 0], rot: [0, Math.PI / 2, 0] },
            { pos: [-ROOM_SIZE / 2, WALL_HEIGHT / 2, 0], rot: [0, Math.PI / 2, 0] }
          ].map((wall, i) => (
            <mesh key={i} position={wall.pos} rotation={wall.rot} receiveShadow>
              <boxGeometry args={[ROOM_SIZE, WALL_HEIGHT, 0.5]} />
              <meshStandardMaterial color={wallColor} roughness={0.9} />
            </mesh>
          ))}

          {/* 天井 */}
          <mesh rotation={[Math.PI / 2, 0, 0]} position={[0, WALL_HEIGHT, 0]}>
            <planeGeometry args={[ROOM_SIZE, ROOM_SIZE]} />
            <meshStandardMaterial color="#ffffff" />
          </mesh>

          {/* NFT */}
          {positions.map(({ nft, pos, rot }, i) => (
            <ArtFrame
              key={nft.tokenId}
              nft={nft}
              position={pos}
              rotation={rot}
              onClick={() => onSelectNFT(nft)}
            />
          ))}

          {/* オフィス家具（2階のみ） */}
          {!isMuseum && (
            <>
              <mesh position={[-12, 0.4, -12]} castShadow>
                <boxGeometry args={[3, 0.8, 1.5]} />
                <meshStandardMaterial color="#5d4e37" />
              </mesh>
              <mesh position={[15, 1, -15]}>
                <coneGeometry args={[0.8, 2, 8]} />
                <meshStandardMaterial color="#228b22" />
              </mesh>
            </>
          )}
        </group>
      );
    };

    // ==========================================
    // NPC犬たち
    // ==========================================
    const NPCDog = ({ initialPosition, colorIndex }) => {
      const group = useRef();
      const [targetPos, setTargetPos] = useState(initialPosition);
      const [isMoving, setIsMoving] = useState(false);
      const waitTime = useRef(Math.random() * 3);

      useFrame((state, delta) => {
        if (!group.current) return;

        if (waitTime.current > 0) {
          waitTime.current -= delta;
          setIsMoving(false);
          return;
        }

        const current = group.current.position;
        const dist = Math.sqrt(
          Math.pow(targetPos[0] - current.x, 2) + Math.pow(targetPos[2] - current.z, 2)
        );

        if (dist > 0.5) {
          const dir = new THREE.Vector3(
            targetPos[0] - current.x,
            0,
            targetPos[2] - current.z
          ).normalize();
          current.x += dir.x * delta * 2;
          current.z += dir.z * delta * 2;
          group.current.rotation.y = Math.atan2(dir.x, dir.z);
          setIsMoving(true);
        } else {
          setTargetPos([
            (Math.random() - 0.5) * (ROOM_SIZE - 10),
            0,
            (Math.random() - 0.5) * (ROOM_SIZE - 10)
          ]);
          waitTime.current = 2 + Math.random() * 4;
          setIsMoving(false);
        }
      });

      return (
        <group ref={group} position={initialPosition}>
          <DogAvatar colorIndex={colorIndex} isMoving={isMoving} />
        </group>
      );
    };

    // ==========================================
    // プレイヤー
    // ==========================================
    const Player = ({ moveVector, isDogMode, humanColorIndex, dogColorIndex, isFlying, controlsRef }) => {
      const group = useRef();
      const position = useRef(new THREE.Vector3(0, 0, 5));
      const velocity = useRef(new THREE.Vector3());
      const [isMoving, setIsMoving] = useState(false);
      const { camera } = useThree();

      useFrame(() => {
        if (!group.current || !controlsRef.current) return;

        const moving = Math.abs(moveVector.x) > 0.01 || Math.abs(moveVector.y) > 0.01;
        setIsMoving(moving);

        if (moving) {
          const fwd = new THREE.Vector3();
          camera.getWorldDirection(fwd);
          fwd.y = 0;
          fwd.normalize();

          const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0, 1, 0));
          const moveDir = new THREE.Vector3()
            .addScaledVector(fwd, moveVector.y)
            .addScaledVector(right, moveVector.x)
            .normalize();

          const speed = isDogMode ? 0.08 : 0.06;
          velocity.current.lerp(moveDir.multiplyScalar(speed), 0.15);

          if (moveDir.length() > 0.01) {
            group.current.rotation.y = Math.atan2(moveDir.x, moveDir.z);
          }
        } else {
          velocity.current.lerp(new THREE.Vector3(0, 0, 0), 0.15);
        }

        position.current.add(velocity.current);

        const limit = ROOM_SIZE / 2 - 2;
        position.current.x = Math.max(-limit, Math.min(limit, position.current.x));
        position.current.z = Math.max(-limit, Math.min(limit, position.current.z));

        const targetY = isFlying ? 5 : 0;
        position.current.y = THREE.MathUtils.lerp(position.current.y, targetY, 0.05);

        group.current.position.copy(position.current);

        const camTargetY = isDogMode ? position.current.y + 0.5 : position.current.y + 1.2;
        controlsRef.current.target.lerp(
          new THREE.Vector3(position.current.x, camTargetY, position.current.z),
          0.1
        );
        controlsRef.current.update();
      });

      return (
        <group ref={group}>
          {isDogMode ? (
            <DogAvatar colorIndex={dogColorIndex} isMoving={isMoving} />
          ) : (
            <HumanAvatar colorIndex={humanColorIndex} isMoving={isMoving} />
          )}
        </group>
      );
    };

    // ==========================================
    // ジョイスティック
    // ==========================================
    const Joystick = ({ onMove }) => {
      const [active, setActive] = useState(false);
      const [pos, setPos] = useState({ x: 0, y: 0 });
      const baseRef = useRef();
      const maxDist = 40;

      const handleMove = useCallback((clientX, clientY) => {
        if (!baseRef.current) return;
        const rect = baseRef.current.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let dx = clientX - centerX;
        let dy = clientY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxDist) {
          dx = (dx / dist) * maxDist;
          dy = (dy / dist) * maxDist;
        }
        setPos({ x: dx, y: dy });
        onMove({ x: dx / maxDist, y: -dy / maxDist });
      }, [onMove]);

      useEffect(() => {
        const onEnd = () => {
          setActive(false);
          setPos({ x: 0, y: 0 });
          onMove({ x: 0, y: 0 });
        };
        const onMoveGlobal = (e) => {
          if (active) {
            const touch = e.touches ? e.touches[0] : e;
            handleMove(touch.clientX, touch.clientY);
          }
        };
        window.addEventListener("mousemove", onMoveGlobal);
        window.addEventListener("touchmove", onMoveGlobal, { passive: false });
        window.addEventListener("mouseup", onEnd);
        window.addEventListener("touchend", onEnd);
        return () => {
          window.removeEventListener("mousemove", onMoveGlobal);
          window.removeEventListener("touchmove", onMoveGlobal);
          window.removeEventListener("mouseup", onEnd);
          window.removeEventListener("touchend", onEnd);
        };
      }, [active, handleMove, onMove]);

      return (
        <div className="fixed bottom-12 left-1/2 -translate-x-1/2 z-20">
          <div
            ref={baseRef}
            className="w-32 h-32 rounded-full bg-white/10 backdrop-blur border border-white/20 flex items-center justify-center cursor-pointer"
            onMouseDown={(e) => { setActive(true); handleMove(e.clientX, e.clientY); }}
            onTouchStart={(e) => { setActive(true); handleMove(e.touches[0].clientX, e.touches[0].clientY); }}
          >
            <div
              className="w-12 h-12 rounded-full bg-white shadow-lg"
              style={{ transform: `translate(${pos.x}px, ${pos.y}px)` }}
            />
          </div>
          <div className="text-white/30 text-xs text-center mt-4 tracking-widest">DRAG TO WALK</div>
        </div>
      );
    };

    // ==========================================
    // NFTモーダル
    // ==========================================
    const NFTModal = ({ nft, onClose }) => {
      if (!nft) return null;

      return (
        <div 
          className="fixed inset-0 bg-black/90 backdrop-blur z-50 flex items-center justify-center p-4"
          onClick={onClose}
        >
          <div 
            className="bg-zinc-900 rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex flex-col md:flex-row">
              <div className="w-full md:w-1/2 bg-black p-8 flex flex-col items-center justify-center gap-4">
                <img 
                  src={`https://wsrv.nl/?url=${encodeURIComponent(nft.imageUrl)}`}
                  alt={`TAF DOG #${nft.tokenId}`}
                  className="max-w-full max-h-[40vh] object-contain"
                />
                {nft.changeRule && nft.stateImageUrl && (
                  <>
                    <div className="text-white/50 text-sm">↓ 変化後 ↓</div>
                    <img
                      src={`https://wsrv.nl/?url=${encodeURIComponent(nft.stateImageUrl)}`}
                      alt="変化後"
                      className="max-w-full max-h-[30vh] object-contain opacity-80"
                    />
                  </>
                )}
              </div>
              <div className="w-full md:w-1/2 p-8">
                <h2 className="text-3xl font-bold text-white mb-4">TAF DOG #{nft.tokenId}</h2>
                <div className="space-y-4">
                  <div>
                    <div className="text-white/50 text-sm mb-1">Owner</div>
                    <div className="text-white font-mono text-sm">{nft.ownerShort}</div>
                  </div>
                  {nft.changeRule && (
                    <div>
                      <div className="text-white/50 text-sm mb-1">変化条件</div>
                      <div className="text-yellow-400">{nft.changeRule}</div>
                    </div>
                  )}
                  <div className="text-white/60 text-sm">
                    TAF DOGコレクションのユニークな作品。ローポリゴンの美学と、どこか哀愁漂う表情が特徴です。
                  </div>
                </div>
                <div className="mt-8 flex gap-4">
                  <a
                    href={`https://opensea.io/ja/assets/matic/${NFT_CONFIG.contractAddress}/${nft.tokenId}`}
                    target="_blank"
                    className="bg-white text-black px-6 py-3 rounded-full font-bold text-sm"
                  >
                    OpenSea
                  </a>
                  <button
                    onClick={onClose}
                    className="bg-zinc-700 text-white px-6 py-3 rounded-full font-bold text-sm"
                  >
                    閉じる
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // ==========================================
    // メインシーン
    // ==========================================
    const Scene = ({ floor, nfts, moveVector, isDogMode, humanColorIndex, dogColorIndex, isFlying, onSelectNFT, targetRefs, beans, onBeanComplete }) => {
      const controlsRef = useRef();
      const lighting = getLighting();

      return (
        <>
          <ambientLight color={lighting.ambient} intensity={lighting.intensity} />
          <directionalLight position={[10, 20, 10]} intensity={0.8} castShadow />
          <fog attach="fog" args={["#111", 10, 50]} />

          <OrbitControls
            ref={controlsRef}
            enablePan={false}
            enableZoom={true}
            minDistance={2}
            maxDistance={15}
            maxPolarAngle={Math.PI / 2 - 0.1}
          />

          <Room floor={floor} nfts={nfts} onSelectNFT={onSelectNFT} />

          <Player
            moveVector={moveVector}
            isDogMode={isDogMode}
            humanColorIndex={humanColorIndex}
            dogColorIndex={dogColorIndex}
            isFlying={isFlying}
            controlsRef={controlsRef}
          />

          {/* NPC犬 */}
          {[...Array(5)].map((_, i) => (
            <NPCDog
              key={i}
              initialPosition={[(Math.random() - 0.5) * 20, 0, (Math.random() - 0.5) * 20]}
              colorIndex={i}
            />
          ))}

          {/* 投げるターゲット */}
          {[[15, 0, 15], [-15, 0, 15], [15, 0, -15], [-15, 0, -15]].map((pos, i) => (
            <TargetCharacter key={i} position={pos} onHit={targetRefs[i]} />
          ))}

          {/* 飛んでる豆 */}
          {beans.map((bean, i) => (
            <Bean
              key={bean.id}
              startPos={bean.startPos}
              targetPos={bean.targetPos}
              onComplete={() => onBeanComplete(bean.id, bean.targetIndex)}
            />
          ))}
        </>
      );
    };

    // ==========================================
    // メインApp
    // ==========================================
    const App = () => {
      const [isDogMode, setIsDogMode] = useState(false);
      const [humanColorIndex, setHumanColorIndex] = useState(0);
      const [dogColorIndex, setDogColorIndex] = useState(0);
      const [isFlying, setIsFlying] = useState(false);
      const [currentFloor, setCurrentFloor] = useState(1);
      const [moveVector, setMoveVector] = useState({ x: 0, y: 0 });
      const [selectedNFT, setSelectedNFT] = useState(null);
      const [beans, setBeans] = useState([]);
      const targetRefs = [useRef(), useRef(), useRef(), useRef()];

      // フロア別NFT
      const floorNFTs = useMemo(() => {
        // 仮の振り分け（実際はAPI連携後に所有者で分ける）
        return currentFloor === 1 ? ALL_NFTS.slice(0, 80) : ALL_NFTS.slice(80, 100);
      }, [currentFloor]);

      const handleThrow = () => {
        const targetIndex = Math.floor(Math.random() * 4);
        const targetPos = [[15, 1.5, 15], [-15, 1.5, 15], [15, 1.5, -15], [-15, 1.5, -15]][targetIndex];
        
        setBeans(prev => [...prev, {
          id: Date.now(),
          startPos: [0, 1.2, 5],
          targetPos,
          targetIndex
        }]);
      };

      const handleBeanComplete = (id, targetIndex) => {
        setBeans(prev => prev.filter(b => b.id !== id));
        if (targetRefs[targetIndex].current) {
          targetRefs[targetIndex].current();
        }
      };

      const handleHumanClick = () => {
        if (isDogMode) {
          setIsDogMode(false);
          setIsFlying(false);
        } else {
          setHumanColorIndex(prev => (prev + 1) % HUMAN_COLORS.length);
        }
      };

      const handleDogClick = () => {
        if (!isDogMode) {
          setIsDogMode(true);
          setIsFlying(false);
        } else {
          setDogColorIndex(prev => (prev + 1) % DOG_COLORS.length);
        }
      };

      return (
        <div className="relative w-full h-full bg-black">
          <Canvas shadows camera={{ position: [0, 3, 8], fov: 60 }}>
            <Suspense fallback={null}>
              <Scene
                floor={currentFloor}
                nfts={floorNFTs}
                moveVector={moveVector}
                isDogMode={isDogMode}
                humanColorIndex={humanColorIndex}
                dogColorIndex={dogColorIndex}
                isFlying={isFlying}
                onSelectNFT={setSelectedNFT}
                targetRefs={targetRefs}
                beans={beans}
                onBeanComplete={handleBeanComplete}
              />
            </Suspense>
          </Canvas>

          {/* ヘッダー */}
          <div className="absolute top-0 left-0 right-0 p-4 flex justify-between items-center z-10">
            <h1 className="text-white text-xl font-bold tracking-wider">TAF DOG MUSEUM</h1>
            <div className="flex gap-2">
              <button
                onClick={handleHumanClick}
                className={`px-4 py-2 rounded-full font-bold text-sm transition-all ${
                  !isDogMode ? "bg-white text-black" : "bg-black/50 text-white/70 border border-white/20"
                }`}
              >
                HUMAN
              </button>
              <button
                onClick={handleDogClick}
                className={`px-4 py-2 rounded-full font-bold text-sm transition-all ${
                  isDogMode ? "bg-white text-black" : "bg-black/50 text-white/70 border border-white/20"
                }`}
              >
                DOG
              </button>
            </div>
          </div>

          {/* フロアインジケーター */}
          <div className="absolute top-1/2 left-4 -translate-y-1/2 flex flex-col gap-2 z-10">
            <button
              onClick={() => setCurrentFloor(2)}
              className={`w-12 h-12 rounded-lg font-bold text-sm ${
                currentFloor === 2 ? "bg-white text-black" : "bg-black/50 text-white/70 border border-white/20"
              }`}
            >
              2F
            </button>
            <button
              onClick={() => setCurrentFloor(1)}
              className={`w-12 h-12 rounded-lg font-bold text-sm ${
                currentFloor === 1 ? "bg-white text-black" : "bg-black/50 text-white/70 border border-white/20"
              }`}
            >
              1F
            </button>
          </div>

          {/* 右サイドボタン */}
          <div className="absolute bottom-32 right-4 flex flex-col gap-3 z-10">
            {!isDogMode && (
              <button
                onClick={() => setIsFlying(!isFlying)}
                className={`w-14 h-14 rounded-full font-bold text-xs ${
                  isFlying ? "bg-blue-500 text-white" : "bg-black/50 text-white/70 border border-white/20"
                }`}
              >
                FLY
              </button>
            )}
            <button
              onClick={handleThrow}
              className="w-14 h-14 rounded-full bg-red-500/80 text-white border border-red-300 font-bold text-xs"
            >
              THROW
            </button>
          </div>

          {/* ジョイスティック */}
          <Joystick onMove={setMoveVector} />

          {/* NFTモーダル */}
          <NFTModal nft={selectedNFT} onClose={() => setSelectedNFT(null)} />
        </div>
      );
    };

    // ==========================================
    // 起動
    // ==========================================
    const container = document.getElementById("root");
    document.getElementById("loading").style.display = "none";
    if (container) {
      createRoot(container).render(<App />);
    }
  </script>
</body>
</html>
